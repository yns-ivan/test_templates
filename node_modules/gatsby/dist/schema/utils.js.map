{"version":3,"file":"utils.js","names":["toNodeTypeNames","schema","gqlTypeName","gqlType","getType","isObjectType","isAbstractType","possibleTypes","getPossibleTypes","filter","type","getInterfaces","some","iface","name","map","isObjectOrInterfaceTypeComposer","ObjectTypeComposer","InterfaceTypeComposer","fieldNeedToResolve","typeComposer","schemaComposer","fieldName","nodeTypeNames","possibleTCs","getAnyTC","tc","getFieldExtension","fieldPathNeedToResolve","selector","schemaCustomization","composer","store","getState","Error","selectors","split","isInterfaceType","i","length","nextType","getNamedType","getFields","getResolvedFields","node","typeName","internal","resolvedNodes","resolvedNodesCache","get","id"],"sources":["../../src/schema/utils.ts"],"sourcesContent":["import {\n  isAbstractType,\n  getNamedType,\n  GraphQLSchema,\n  isObjectType,\n  isInterfaceType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from \"graphql\"\nimport {\n  InterfaceTypeComposer,\n  NamedTypeComposer,\n  ObjectTypeComposer,\n  SchemaComposer,\n} from \"graphql-compose\"\n\nimport type { IGatsbyNodePartial } from \"../datastore/in-memory/indexing\"\nimport { IGatsbyNode } from \"../internal\"\nimport { store } from \"../redux\"\n\nexport const toNodeTypeNames = (\n  schema: GraphQLSchema,\n  gqlTypeName:\n    | string\n    | GraphQLObjectType\n    | GraphQLInterfaceType\n    | GraphQLUnionType\n): Array<string> => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType || !(isObjectType(gqlType) || isAbstractType(gqlType))) {\n    return []\n  }\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nexport function isObjectOrInterfaceTypeComposer(\n  type: NamedTypeComposer<any>\n): type is ObjectTypeComposer | InterfaceTypeComposer {\n  return (\n    type instanceof ObjectTypeComposer || type instanceof InterfaceTypeComposer\n  )\n}\n\nexport const fieldNeedToResolve = ({\n  schema,\n  gqlType,\n  typeComposer,\n  schemaComposer,\n  fieldName,\n}: {\n  schema: GraphQLSchema\n  gqlType: GraphQLObjectType | GraphQLInterfaceType\n  typeComposer: ObjectTypeComposer<any> | InterfaceTypeComposer<any>\n  schemaComposer: SchemaComposer<any>\n  fieldName: string\n}): boolean => {\n  const nodeTypeNames = toNodeTypeNames(schema, gqlType)\n\n  const possibleTCs: Array<ObjectTypeComposer | InterfaceTypeComposer> = [\n    typeComposer,\n    ...nodeTypeNames\n      .map(name => schemaComposer.getAnyTC(name))\n      .filter(isObjectOrInterfaceTypeComposer),\n  ]\n\n  for (const tc of possibleTCs) {\n    if (tc.getFieldExtension(fieldName, `needsResolve`) || false) {\n      return true\n    }\n  }\n\n  return false\n}\n\nexport const fieldPathNeedToResolve = ({\n  selector,\n  type,\n}: {\n  selector: string\n  type: string | GraphQLObjectType | GraphQLInterfaceType\n}): boolean => {\n  const {\n    schema,\n    schemaCustomization: { composer: schemaComposer },\n  } = store.getState()\n\n  if (!schemaComposer) {\n    throw new Error(`Schema composer isn't set yet`)\n  }\n\n  const selectors =\n    typeof selector === `string` ? selector.split(`.`) : selector\n\n  let gqlType = typeof type === `string` ? schema.getType(type) : type\n\n  if (!gqlType || !(isObjectType(gqlType) || isInterfaceType(gqlType))) {\n    return false\n  }\n\n  for (let i = 0; i < selectors.length; i++) {\n    const fieldName = selectors[i]\n    const typeComposer = schemaComposer.getAnyTC(gqlType.name)\n\n    if (!isObjectOrInterfaceTypeComposer(typeComposer)) {\n      return false\n    }\n\n    if (\n      fieldNeedToResolve({\n        schema,\n        gqlType,\n        typeComposer,\n        schemaComposer,\n        fieldName,\n      })\n    ) {\n      return true\n    }\n\n    const nextType = getNamedType(gqlType.getFields()[fieldName].type)\n    if (!nextType || !(isObjectType(nextType) || isInterfaceType(nextType))) {\n      return false\n    } else {\n      gqlType = nextType\n    }\n  }\n\n  return false\n}\n\nexport function getResolvedFields(\n  node: IGatsbyNode | IGatsbyNodePartial\n): undefined | Record<string, any> {\n  const typeName = node.internal.type\n  const resolvedNodes = store.getState().resolvedNodesCache.get(typeName)\n  return resolvedNodes?.get(node.id)\n}\n"],"mappings":"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"}